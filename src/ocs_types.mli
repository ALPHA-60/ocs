(* Main types used *)

open Ocs_vartable

(* We have to declare most types here to avoid cross-dependencies between
   compilation units.  *)

type sval = 
  (* Global variables are set to Sunbound when referenced but not assigned.  *)
    Sunbound

  (* List terminator.  *)
  | Snull

  (* End-of-file indicator.  *)
  | Seof

  (* Boolean values.  This is more compact than Sbool of bool.  *)
  | Strue
  | Sfalse

  (* String object.  *)
  | Sstring of string

  (* Symbol type.  Symbols should not be created directly, but using
     Ocs_sym.get_symbol, which ensures that they are unique and can be
     compared using ==.  *)
  | Ssymbol of string

  (* Numeric types.  *)
  | Sint of int
  | Sreal of float
  | Scomplex of Complex.t
  | Sbigint of Big_int.big_int
  | Srational of Ratio.ratio

  (* Character.  *)
  | Schar of char

  (* A pair (list element).  *)
  | Spair of spair

  (* Vector.  *)
  | Svector of sval array

  (* Port object.  *)
  | Sport of Ocs_port.port

  (* A closure created by combining the process reference with the
     local environment at that point of execution.  *)
  | Sproc of sproc * sval array array

  (* Primitive function.  *)
  | Sprim of sprim

  (* Delayed expression.  *)
  | Spromise of spromise

  (* A set of values returned by the 'values' primitive,
     deconstructed into multiple parameters by call-with-values.  *)
  | Svalues of sval array

  (* A symbol explicitly tied to an environment that defines its scope.
     These symbols are generated by macro expansions and eliminated
     prior to evaluation.  *)
  | Sesym of env * sval

  (* Wrapped values are stub functions that encapsulate external values
     of unknown types.  *)
  | Swrapped of (unit -> unit)

  (* An unspecified value.  *)
  | Sunspec

  (* The actual type of a pair (cons cell).  *)
and spair =
  {
    mutable car : sval;
    mutable cdr : sval
  }

  (* Primitive structure.  *)
and sprim =
  {
    prim_fun : primf;
    prim_name : string
  }

  (* Primitive function types.  *)
and primf =
  (* Simple functional interface to primitives with a small, constant
     number of arguments.  *)
    Pf0 of (unit -> sval)
  | Pf1 of (sval -> sval)
  | Pf2 of (sval -> sval -> sval)
  | Pf3 of (sval -> sval -> sval -> sval)

  (* Functional interface to primitives with a variable number of arguments.  *)
  | Pfn of (sval array -> sval)

  (* Continuation-based interface to primitives, also includes the thread
     and supports a variable number of arguments.  *)
  | Pfcn of (thread -> (sval -> unit) -> sval array -> unit)

  (* Procedure structure.  *)
and sproc =
  {
    proc_body : code;
    proc_nargs : int;
    proc_has_rest : bool;
    proc_frame_size : int;
    mutable proc_name : string
  }

  (* Delayed expression.  *)
and spromise =
  {
    promise_code : code;
    mutable promise_val : sval option;
    mutable promise_th : thread option	(* Copy of the thread state *)
  }

  (* Code types are used to represent analyzed expressions prepared for
     evaluation.  *)
and code =
    Cval of sval
  | Cseq2 of code * code
  | Cseq3 of code * code * code
  | Cseqn of code array
  | Cand2 of code * code
  | Cand3 of code * code * code
  | Candn of code array
  | Cor2 of code * code
  | Cor3 of code * code * code
  | Corn of code array
  | Cif of code * code * code
  | Csetg of gvar * code
  | Csetl of int * int * code
  | Cdefine of gvar * code
  | Cgetg of gvar
  | Cgetl of int * int
  | Capply0 of code
  | Capply1 of code * code
  | Capply2 of code * code * code
  | Capply3 of code * code * code * code
  | Capplyn of code * code array
  | Clambda of sproc
  | Cqqp of code * code
  | Cqqv of code array
  | Cqqvs of code list
  | Cqqspl of code
  | Ccond of (code * code) array
  | Ccondspec of code
  | Ccase of code * (sval array * code) array
  | Cdelay of code

  (* Global variable slot.  *)
and gvar =
  {
    mutable g_sym : sval;
    mutable g_val : sval
  }

  (* Thread state, used during evaluation.  *)
and thread =
  {
    th_frame : sval array;		(* Current local frame.  *)
    th_display : sval array array;	(* Current display.  *)
    th_depth : int;			(* Display depth.  *)
    th_stdin : sval;			(* Default input port.  *)
    th_stdout : sval;			(* Default output port.  *)
    th_dynext : dynext option		(* Current dynamic extent.  *)
  }

  (* Bindings, used during analysis.  *)
and vbind =
    Vglob of gvar
  | Vloc of int * int
  | Vsyntax of (env -> sval array -> code)
  | Vmacro of (env -> sval array -> sval)
  | Vkeyword of string

  (* Environment, used during analysis.  *)
and env =
  {
    env_depth : int;
    env_vartable : vbind vartable;
    env_frame_size : int ref;
    mutable env_tagged : (env * sval * vbind) list
  }

  (* Dynamic extents are associated with threads and continuations.  *)
and dynext =
  {
    dynext_parent : dynext option;
    dynext_depth : int;
    dynext_before : thread * code;
    dynext_after : thread * code
  }

